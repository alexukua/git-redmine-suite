#!/usr/bin/perl
use feature 'say';
use strict;
use warnings;
use Encode;
use DateTime;
use Date::Parse;

my $TRIANGLE = Encode::encode( 'utf8', "\x{25B8}" );

{

    package MyOpts;
    use Moo;
    use MooX::Options;
    option 'project' => (
        is       => 'ro',
        format   => 's',
        required => 1,
        doc      => 'the id or slug of the project to check',
    );
    option 'status_id' => (
        is       => 'ro',
        format   => 'i',
        required => 1,
        doc      => 'status id of the review todo',
    );
    option 'assigned_to_id' => (
        is       => 'ro',
        format   => 'i',
        required => 1,
        doc      => 'assigned_to id of the review todo',
    );
    option 'auth_key' => (
        is       => 'ro',
        format   => 's',
        required => 1,
        doc      => 'your auth key',
    );
    option 'server_url' => (
        is       => 'ro',
        format   => 's',
        required => 1,
        doc      => 'the redmine url of the server',
    );
    option 'trace' => (
        is      => 'ro',
        default => sub {0},
        doc     => 'debug mode',
    );
    option 'ids_only' => (
        is  => 'ro',
        doc => 'only show the list of ids',
    );
    1;
};

my $opt     = MyOpts->new_with_options;
my $project = $opt->project;

use Redmine::API;
my $r = Redmine::API->new(
    'auth_key' => $opt->auth_key,
    'base_url' => $opt->server_url . '/projects/' . $project,
    'trace'    => $opt->trace,
);

my $status_id      = $opt->status_id;
my $assigned_to_id = $opt->assigned_to_id;
my %tasks;
my %parent;

my $offset = 0;
my $total_count;
my $loop=0;

#loop until we have no more data
$|=1;

my %s_updated_on;
sub s_updated_on_add {
    my ($id, $t) = @_;
    $s_updated_on{$id} = $t unless defined $s_updated_on{$id} && $s_updated_on{$id} < $t;
}

for ( ;; ) {
    my $resp = $r->issues->list->all(
        status_id      => $status_id,
        assigned_to_id => $assigned_to_id,
        offset         => $offset,
    );
    my $content = $resp->content;
    $total_count //= $content->{total_count};
    last unless $total_count;

    my $issues = $content->{issues};
    my $now    = DateTime->now;
    for my $issue (@$issues) {
        my $duration_str = '???';
        my $updated_on_time;
        eval 
        {
            my $updated_on_str  = $issue->{updated_on};
            $updated_on_time = str2time($updated_on_str);
            
            my $updated_on
                = DateTime->from_epoch( epoch => $updated_on_time );
            my %duration = ( $now - $updated_on )->deltas;

            if ( $duration{months} ) {
                $duration_str = sprintf( '%d months and %d days ago',
                    $duration{months}, $duration{days} );
            }
            elsif ( $duration{days} ) {
                $duration_str = sprintf( '%d days ago', $duration{days} );
            }
            else {
                $duration_str = 'today';
            }
        };
        my $task_id = $issue->{id};
        my $parent_id = $issue->{parent} ? $issue->{parent}->{id} : 0;
        if ($updated_on_time) {
            #save for sorting
            s_updated_on_add($task_id, $updated_on_time);
            s_updated_on_add($parent_id,$updated_on_time);
        }

        $parent{$parent_id} //= [];
        push @{ $parent{$parent_id} }, $task_id;
        my $title = join( "",
            encode( 'UTF8', $issue->{tracker}->{name} ),
            " # ", $task_id, " : ", encode( 'UTF8', $issue->{subject} ) );
        $tasks{$task_id} = sprintf( "%s, updated %s", $title, $duration_str );
    }
    $offset += $content->{limit};
    last unless $offset < $total_count;
    next if $opt->ids_only;
    $loop=1;
    print ".";
}
say "
" if $loop;

if ( $opt->ids_only ) {
    say join( " ", sort { ($s_updated_on{$a}//0) <=> ($s_updated_on{$b}//0) } keys %tasks );
    exit 0;
}

$r = Redmine::API->new(
    'auth_key' => $opt->auth_key,
    'base_url' => $opt->server_url,
    'trace'    => $opt->trace,
);

my $redoit = 1;
while ($redoit) {
    $redoit = 0;
    for my $parent_id ( keys %parent ) {
        next if !$parent_id || exists $tasks{$parent_id};
        $redoit = 1;
        my $resp  = $r->issues->issue->get($parent_id);
        my $issue = $resp->content->{issue};
        $tasks{$parent_id} = encode( 'UTF8', $issue->{subject} );
        my $parent_parent_id
            = $issue->{parent} ? $issue->{parent}->{id} : 0;
        $parent{$parent_parent_id} //= [];
        push @{ $parent{$parent_parent_id} }, $parent_id + 0;
        s_updated_on_add($parent_parent_id, $s_updated_on{$parent_id});
    }
}

sub display_tree {
    my %p = @_;
    my $tab = "  " x ( $p{level} );
    for my $task_id ( sort { ($s_updated_on{$a}//0) <=> ($s_updated_on{$b}//0) } @{ $p{parent}{ $p{parent_id} } // [] } ) {
        say "  " . $tab . $TRIANGLE . " " . $p{tasks}{$task_id};
        if ( $p{parent}{$task_id} ) {
            display_tree(
                %p,
                level     => $p{level} + 1,
                parent_id => $task_id
            );
        }
    }
}

display_tree(
    parent    => \%parent,
    tasks     => \%tasks,
    level     => 0,
    parent_id => 0
);
say "";
