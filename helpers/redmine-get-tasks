#!/usr/bin/perl
use feature 'say';
use strict;
use warnings;
use Encode;
use DateTime;
use Date::Parse;

my $TRIANGLE = Encode::encode('utf8', "\x{25B8}");

{
    package MyOpts;
    use Moo;
    use MooX::Options;
    option 'project' => (
        is => 'ro',
        format => 's',
        required => 1,
        doc => 'the id or slug of the project to check',
    );
    option 'status_id' => (
        is => 'ro',
        format => 'i',
        required => 1,
        doc => 'status id of the review todo',
    );
    option 'assigned_to_id' => (
        is => 'ro',
        format => 'i',
        required => 1,
        doc => 'assigned_to id of the review todo',
    );
    option 'auth_key' => (
        is => 'ro',
        format => 's',
        required => 1,
        doc => 'your auth key',
    );
    option 'server_url' => (
        is => 'ro',
        format => 's',
        required => 1,
        doc => 'the redmine url of the server',
    );
    option 'trace' => (
        is => 'ro',
        default => sub { 0 },
        doc => 'debug mode',
    );
    option 'ids_only' => (
        is => 'ro',
        doc => 'only show the list of ids',
    );
    1;
};

my $opt = MyOpts->new_with_options;
my $project = $opt->project;

use Redmine::API;
my $r = Redmine::API->new(
    'auth_key' => $opt->auth_key,
    'base_url' => $opt->server_url . '/projects/' . $project,
    'trace' => $opt->trace,
);

my $status_id = $opt->status_id;
my $assigned_to_id = $opt->assigned_to_id;
my %tasks;
my %parent;

my $resp = $r->issues->list->all(status_id => $status_id, assigned_to_id => $assigned_to_id, limit => 1000);
my $content = $resp->content->{issues};
my $now = DateTime->now;
for my $issue(@$content) {
    my $duration_str = '???';
    eval {
        my $updated_on_str = $issue->{updated_on};
        my $updated_on_time = str2time($updated_on_str);
        my $updated_on = DateTime->from_epoch(epoch => $updated_on_time);
        my %duration = ($now - $updated_on)->deltas;
        if ($duration{month}) {
            $duration_str = sprintf('%d months and %d days ago', $duration{month}, $duration{days});
        } elsif($duration{days}) {
            $duration_str = sprintf('%d days ago', $duration{days});
        } else {
            $duration_str = 'today';
        }
    };
    my $task_id = $issue->{id};
    my $parent_id = $issue->{parent} ? $issue->{parent}->{id} : 0;
    $parent{$parent_id} //= [];
    push @{$parent{$parent_id}}, $task_id;
    $tasks{$task_id} = sprintf("%s (#%d), updated %s", $issue->{subject}, $issue->{id}, $duration_str);
}

if ($opt->ids_only) {
    say join(" ", sort { $a <=> $b } keys %tasks);
    exit 0;
}

$r = Redmine::API->new(
    'auth_key' => $opt->auth_key,
    'base_url' => $opt->server_url,
    'trace' => $opt->trace,
);

my $redoit = 1;
while($redoit) {
    $redoit = 0;
    for my $parent_id (keys %parent) {
        next if !$parent_id || exists $tasks{$parent_id};
        $redoit = 1;
        $resp = $r->issues->issue->get($parent_id);
        my $issue = $resp->content->{issue};
        $tasks{$parent_id} = $issue->{subject};
        my $parent_parent_id = $issue->{parent} ? $issue->{parent}->{id} : 0;
        $parent{$parent_parent_id} //= [];
        push @{$parent{$parent_parent_id}}, $parent_id + 0;
    }
}

sub display_tree {
    my %p = @_;
    my $tab = "  " x ($p{level});
    for my $task_id(@{$p{parent}{$p{parent_id}}}) {
        say "  " . $tab. $TRIANGLE . " " . $p{tasks}{$task_id};
        if ($p{parent}{$task_id}) {
            display_tree(%p, level => $p{level} + 1, parent_id => $task_id);
        }
        say "" if !$p{level};
    }
}

display_tree(parent => \%parent, tasks => \%tasks, level => 0, parent_id => 0);
