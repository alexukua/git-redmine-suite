#!/usr/bin/perl
use feature 'say';
use strict;
use warnings;
use DateTime;
use Date::Parse;
use List::MoreUtils qw/uniq/;
use Carp;
use Term::Size 'chars';
use utf8::all;

my ($columns) = chars;
$columns ||= 80;

my $TRIANGLE = "\x{25B8}";

{

    package MyOpts;
    use Moo;
    use MooX::Options;
    option 'project' => (
        is     => 'ro',
        format => 's',
        doc    => 'the id or slug of the project to check',
    );
    option 'status_id' => (
        is     => 'ro',
        format => 'i',
        doc    => 'status id of the review todo',
    );
    option 'assigned_to_id' => (
        is     => 'ro',
        format => 'i',
        doc    => 'assigned_to id of the review todo',
    );
    option 'auth_key' => (
        is       => 'ro',
        format   => 's',
        required => 1,
        doc      => 'your auth key',
    );
    option 'server_url' => (
        is       => 'ro',
        format   => 's',
        required => 1,
        doc      => 'the redmine url of the server',
    );
    option 'trace' => (
        is      => 'ro',
        default => sub {0},
        doc     => 'debug mode',
    );
    option 'ids_only' => (
        is  => 'ro',
        doc => 'only show the list of ids',
    );
    option 'cf_id' => (
        is     => 'ro',
        doc    => 'custom field id',
        format => 'i',
    );
    option 'cf_val' => (
        is     => 'ro',
        doc    => 'custom field value',
        format => 's',
    );
    1;
};

my $opt     = MyOpts->new_with_options;
my $project = $opt->project;

use Redmine::API;
my $r = Redmine::API->new(
    'auth_key' => $opt->auth_key,
    'base_url' => $opt->server_url,
    'trace'    => $opt->trace,
);

#loop until we have no more data
$| = 1;

my %s_updated_on;

sub s_updated_on_add {
    my ( $p, $id, $t ) = @_;
    $t //= 0;
    $s_updated_on{$p}{$id} = $t
        unless defined $s_updated_on{$p}{$id} && $s_updated_on{$p}{$id} < $t;
}

my %search;

sub search_add {
    my ( $key, $val ) = @_;
    $search{$key} = $val if defined $val;
}

search_add status_id      => $opt->status_id;
search_add project_id     => $project;
search_add assigned_to_id => $opt->assigned_to_id;
if ( defined $opt->cf_id && defined $opt->cf_val ) {
    search_add 'cf_' . $opt->cf_id => $opt->cf_val;
}

my %projects;

my $offset = 0;
my $total_count;
my $loop = 0;
for ( ;; ) {
    my $resp = $r->issues->list->all( %search, offset => $offset, );
    my $content = $resp->content;
    $total_count //= $content->{total_count};
    last unless $total_count;

    my $issues = $content->{issues};
    my $now    = DateTime->now;
    for my $issue (@$issues) {

        my $project_identifier = $issue->{project}->{identifier};
        my $project            = (
            $projects{$project_identifier} //= {
                tasks  => {},
                parent => {},
            }
        );

        my $updated_on_time = eval {
            str2time($issue->{updated_on});
        } // -1;

        my $task_id = $issue->{id};
        my $parent_id = $issue->{parent} ? $issue->{parent}->{id} : 0;
        if ($updated_on_time) {
            #save for sorting
            s_updated_on_add( $project_identifier, $task_id,
                $updated_on_time );
            s_updated_on_add( $project_identifier, $parent_id,
                $updated_on_time );
        }

        $project->{parent}{$parent_id} //= [];
        push @{ $project->{parent}{$parent_id} }, $task_id;
        my $title = join( "",
            $issue->{tracker}->{name},
            " # ", $task_id, " : ", $issue->{subject} );
        my $assigned_to = $issue->{assigned_to}->{name};
        $project->{tasks}{$task_id}
            = { title => $title, assigned_to => $assigned_to };
    }
    $offset += $content->{limit};
    last unless $offset < $total_count;
    next if $opt->ids_only;
    $loop = 1;
    print ".";
}
say "
" if $loop;

if ( $opt->ids_only ) {
    say join( " ",
        uniq sort { $a <=> $b }
            map   { keys %{ $_->{tasks} } } values %projects );
    exit 0;
}

sub trunc_str {
    my ($str, $max) = @_;
    if (length($str) > $max) {
        return substr($str, 0, $max - 4) . ' ...';
    } else {
        return $str;
    }
}
sub format_str {
    my ($pad, $title, $assigned_to, $updated_on) = @_;
    $assigned_to //= 'nobody';
    my $date_str = DateTime->from_epoch(epoch => $updated_on)->strftime('%Y/%m/%d %H:%M');
    my $mtitle = $columns - 42;
    my $format_str = "%-" . ($mtitle) . "s [ %15s ] [ %s ]";

    return sprintf($format_str, trunc_str($pad . $title, $mtitle), trunc_str($assigned_to, 15), $date_str);
}

sub display_tree {
    my %p = @_;
    my $tab = "  " x ( $p{level} );
    for my $task_id (
        sort { ( $p{s_updated_on}{$a} // 0 ) <=> ( $p{s_updated_on}{$b} // 0 ) }
        @{ $p{parent}{ $p{parent_id} } // [] } )
    {
        say format_str("  " . $tab . $TRIANGLE . " ", $p{tasks}{$task_id}{title}, $p{tasks}{$task_id}{assigned_to}, $p{s_updated_on}{$task_id});
        if ( $p{parent}{$task_id} ) {
            display_tree(
                %p,
                level     => $p{level} + 1,
                parent_id => $task_id
            );
        }
    }
}

for my $project_identifier ( sort { $a cmp $b } keys %projects ) {
    say "[$project_identifier]";
    say "";
    my %parent = %{$projects{$project_identifier}{parent}};
    my %tasks = %{$projects{$project_identifier}{tasks}};

    my $redoit = 1;
    while ($redoit) {
        $redoit = 0;
        for my $parent_id ( keys %parent ) {
            next if !$parent_id || exists $tasks{$parent_id};
            $redoit = 1;
            my $resp  = $r->issues->issue->get($parent_id);
            my $issue = $resp->content->{issue};
            $tasks{$parent_id} = { title => $issue->{subject}, assigned_to => $issue->{assigned_to}->{name} };
            my $parent_parent_id
                = $issue->{parent} ? $issue->{parent}->{id} : 0;
            $parent{$parent_parent_id} //= [];
            push @{ $parent{$parent_parent_id} }, $parent_id + 0;
            s_updated_on_add( $project_identifier, $parent_parent_id, $s_updated_on{$parent_id} );
        }
    }

    display_tree(
        s_updated_on => $s_updated_on{$project_identifier},
        parent    => \%parent,
        tasks     => \%tasks,
        level     => 0,
        parent_id => 0
    );
    say "";

}
